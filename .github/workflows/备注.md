on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master

push 触发：当你直接推送代码到 main 或 master 分支时，会触发工作流
pull_request 触发：当你创建或更新一个目标分支为 main 或 master 的 Pull Request 时，会触发工作流

实际场景举例：

你在功能分支 feature/login 上开发，向 main 分支提交 PR → ✅ 触发
你直接推送代码到 main 分支 → ✅ 触发
你推送代码到 develop 分支 → ❌ 不触发
你创建针对 develop 分支的 PR → ❌ 不触发

这种配置很常见，用于确保主分支的代码质量，在合并前自动运行测试、构建等检查

VITE_API_BASE_URL
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

## 2025-11-24 VITE_API_BASE_URL 构建变量遗漏记录

- **问题**：`frontend` 和 `admin-frontend` 的 Docker 构建只给 `admin-frontend` 注入了 `VITE_API_BASE_URL`，导致普通前端镜像部署后请求 API 时仍指向默认地址。
- **影响**：线上前端在自建环境中无法调用后端 API，表现为登录等接口全部失败。
- **改动**：在 `deploy.yml` 的矩阵配置里为 `frontend` 与 `admin-frontend` 都设置 `build_args`，并在构建步骤中统一读取 `matrix.build_args`。
- **操作说明**：
  1. 在仓库 `Settings → Secrets and variables → Actions` 添加或更新 `VITE_API_BASE_URL`。
  2. 推送后，GitHub Actions 会为两套前端镜像自动注入该环境变量，无需额外手动操作。


env:  # 定义环境变量
  REGISTRY: ghcr.io  # 容器镜像仓库地址
  IMAGE_NAME: ${{ github.repository }}  # 镜像名称（动态获取）
```

**详细解释：**

1. **REGISTRY: ghcr.io**
   - `ghcr.io` 是 GitHub Container Registry（GitHub 容器注册表）的地址
   - 这是 GitHub 提供的免费 Docker 镜像托管服务
   - 类似于 Docker Hub，但与 GitHub 深度集成

2. **IMAGE_NAME: ${{ github.repository }}**
   - `${{ }}` 是 GitHub Actions 的表达式语法
   - `github.repository` 是一个上下文变量，自动获取当前仓库的完整名称
   - 格式为：`owner/repo-name`（所有者/仓库名）
   
   **举例：**
   - 如果你的仓库是 `https://github.com/john/my-app`
   - 那么 `IMAGE_NAME` 就会是：`john/my-app`


这是一个完整的 GitHub Actions CI/CD 工作流，包含构建和部署两个任务。让我逐步解释：



SSH_HOST:  47.115.133.193
SSH_USERNAME: root
SSH_PRIVATE_KEY:
-----BEGIN OPENSSH PRIVATE KEY-----
请查看C:\Users\admin\.ssh
-----END OPENSSH PRIVATE KEY-----


ssh your_username@your_server_ip

# 添加公钥
mkdir -p ~/.ssh
echo "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIP66XDpLcrkn1OAdLjKogXH06AWUfpb7R/dRYgmv5w7p admin@DESKTOP-74DR9AL" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
chmod 700 ~/.ssh

ssh -i C:\Users\admin\.ssh\id_rsa root@47.115.133.193




**不需要手动配置！**

`secrets.GITHUB_TOKEN` 是 GitHub Actions **自动生成和提供**的临时令牌，每次工作流运行时都会自动创建。

---

## **GITHUB_TOKEN 的特点：**

### **1. 自动提供**
- GitHub Actions 在每次工作流运行时自动注入
- 无需在 Secrets 中手动添加
- 有效期仅限当前工作流运行期间

### **2. 权限范围**
默认权限由工作流中的 `permissions` 字段控制：

```yaml
permissions:
  contents: read    # 读取仓库内容
  packages: write   # 写入包（发布 Docker 镜像到 ghcr.io）
```

### **3. 用途**
在你的工作流中，`GITHUB_TOKEN` 用于两个地方：

**① 登录到 GitHub Container Registry**
```yaml
- name: Log in to Container Registry
  uses: docker/login-action@v3
  with:
    registry: ghcr.io
    username: ${{ github.actor }}
    password: ${{ secrets.GITHUB_TOKEN }}  # ← 自动提供
```

**② 在服务器上拉取私有镜像**
```bash
echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
```

---

## **何时需要手动配置 Token？**

只有以下情况需要手动创建 Personal Access Token (PAT)：

1. **需要更高权限**（如操作其他仓库）
2. **Token 需要长期有效**（如定时任务）
3. **跨仓库操作**

**创建 PAT 的位置：**
GitHub → 右上角头像 → **Settings** → **Developer settings** → **Personal access tokens** → **Tokens (classic)**

---

## **总结：**

✅ **无需配置的（自动提供）：**
- `secrets.GITHUB_TOKEN`
- `github.actor`
- `github.repository`
- `github.ref`
- `github.event_name`

❌ **必须手动配置的：**
- `secrets.SSH_HOST`
- `secrets.SSH_USERNAME`
- `secrets.SSH_PRIVATE_KEY`
- `secrets.SSH_PORT`（可选）
- `secrets.DEPLOY_PATH`（可选）

你的工作流使用默认的 `GITHUB_TOKEN` 就完全够用了！heihei